# 课后总结

这两部分课程囊括了关于计算机硬件和软件许多方向的知识。
我认为丰富还不是它最大的特点，
**最重要的是它帮我建立起了一个非常棒的知识体系**。
这个清晰、简洁又坚实的骨架结构，
可以支撑我不断去深入学习有关计算机任何一个方向的具体内容。

如今的网络虽然让信息变得丰富又触手可及，但是却因为缺少像这门课程所做的知识结构梳理，
所以总让人觉得越学越糊涂，记住的东西越多离真相越远。

所以我的课后总结侧重在回忆出这副”骨架“，
而且在总结的过程中，我发现自己仍然在轻松的惬意地，向这个体系里不断添加着新的知识。

## 计算机的硬件构造

一台计算机，不论有多么先进，都是由是四大类硬件组成的。

### 核心组件，数据存储和芯片
1. 数据存储设备

   如，ROM、RAM
   
   - ROM（read-only memory，只读），用来加载程序指令
   - RAM（random-access memory，可乱序存取），用来存取程序执行中所产生的数据

   本课程里的ROM和RAM是同一种硬件，即硬件结构、原理一样。由一大串Register，寄存器组成。

   <details>
   <summary>数据存储设备还有其他类型</summary>
    
   - DADS（direct-access data storage media，有序存储）
   
     如，CD，DVD，HDD，磁带。

     此类设备的存储地址有远近区别。而RAM的读取可以认为是等距的，读取任何位置所需要的时间和复杂度相同。
   </details>
   
2. 芯片

   由一个ALU、几个Register和一个Program Counter构成一个核心单元。
   本课程的芯片是单核CPU，而更先进的芯片可能包含了多个核心单元，或有更强的计算功能ALU。
  
   - ALU（arithmetic and logic unit），数学和逻辑运算单元，由若干种逻辑门搭建。

   - Register，寄存器，一般由8/16/32/64个bit构成。一个bit能存一位数，0或者1。

     这里的“8/16/32/64”描述的是CPU“线宽”，对应“8位、16位、32位、64位”机。
     
   - Program Counter，指令地址寄存器/程序计数器，由寄存器，步进器，和两个控制信号组成。
    
### 外设，输入和输出
3. 输入设备
  
   向RAM指定地址推送数据
  
4. 输出设备

   从RAM指定地址取用数据

输入和输出设备使用RAM哪段地址，推送的是什么样的数据，这些数据应该被怎样解读，多久刷新一次数据……
这些有关电脑与其他设备之间的分工配合问题，都是靠硬件协议和驱动程序来规范的。

输入和输出设备也可能有芯片，有存储。可以是一台能独立运行的设备，如另一台电脑。
但要承担的职责无外乎往指定地址推送数据，或是从指定地址取用数据。

核心组件是必不可少的，没有芯片就不能做任何运算，另外也必须有可以加载程序的存储，和足够储存程序运算过程的数据空间。
但是外设理论上讲不是必须要有。
  
## 内存（RAM）的结构

### RAM的基础元素，寄存器
 
   RAM的基础单元是Register，寄存器。
   和CPU里的寄存器结构一样，线宽一般也是一样的。同时也是每次进行数据读取的最小单位。
   
   一个寄存器由n个bit组成，一个bit由一个Mux加一个DFF（data flip-flop）组成，存储1位数据：0或1。

   <这里画bit的数字逻辑图>

   这样的一个结构实现了让寄存器在没有接到任何指令时，可以在每个时钟周期结束时，重新刷新一下自己的数据。
   以防止过久没有加载指令，当前存储的数据流失。
   如果接到“加载”指令，load=1，那就把输入端的数据加载进来，
   如果load=0，那么输入端数据怎么变化都不会影响寄存器里的数据。
   
### RAM的结构，实现任意位置等效读取
   
   由不超过2<sup>n</sup>个寄存器组成的RAM，可以仅用一个同样结构的寄存器来完成选址工作。
   找到并存取RAM中任何一个位置的数据，难度和用时都是一样的。
   本课程的寄存器是16位的，但是由于程序指令的最后一位被设计用来区分A或C类指令，
   只能用剩下的15位来做地址选择，所以最大的选址范围是2的15次方，一次可以对32768个寄存器进行等效读取。
   
   <这里画15位register选址结构图>
   
## 芯片（CPU）的结构
### CPU=ALU+2*Register+PC
本课程的芯片是一个CPU（central processing unit），中央处理器。
由1个ALU，2个Register和1个Program Counter构成。

 - ALU（arithmetic and logic unit），数学和逻辑运算单元 

   ALU的构成：
   - 16位全加器 Full Adder（两个半加器Half Adder构成）
   - 16位Mux、16位Not、16位And等

   ALU的结构和所实现的计算：
   - 输入2个16位数据，6个1位的控制信号

     2个16位数据：x(16), y(16);<br>
     6个控制信号：zero x, not x, zero y, not y, + or &, not out; <br>

     这6个控制信号对应的计算步骤是顺序发生的，<br>
     也就是说，先处理x，再处理y，然后对x和y进行计算，再对结果进行一次处理。
     
   - 输出1个16位数据，2个1位的控制信号

     输出数据：out(16)<br>
     控制信号：zero, negative<br>
     
   - 靠6个控制信号可以对输入数据进行的计算是

     直接得到：0, 1, -1, x, y, !x, !y, -x, -y, <br>
     计算：x+1, x-1, y+1, y-1, x+y, x-y, y-x, x&y, x|y

     <这里画ALU的数字逻辑电路图>
          
 - Register，寄存器
   
   - D Register

     存储数据。由C类指令指挥ALU计算并输出结果到这个寄存器里。
     
   - A Register

     接收指令，程序指令如果是A类指令，会直接读到这个寄存器里；<br>
     作为RAM选址器，当需要输出或读取M（即，RAM[A]）时。
     
- PC（Program Counter），指令地址寄存器/程序计数器。
  
  PC的主要构成：
   - 16位增量器/步进器 Incrementer
   - 1位的reset控制信号
   - 1位的load控制信号

  PC是ROM的选址器，可以被手动归零（由reset控制），
  没有指令时每读一行程序（一个时钟周期）会自+1，
  也可以由C类指令控制将A寄存器的数据输入到PC里。
     
### CPU的结构

 - D寄存器 作为ALU的一个输入（x），
 - A寄存器/RAM[A] 作为ALU的另一个输入（y），
 - A寄存器可以输出到PC，
 - ALU可以输出到D寄存器，A寄存器，M（RAM[A]）里，
   可以输出到这三个中的任意一个或多个位置，也可以不输出。
 - PC 作为ROM的选址器，会把ROM[PC]输入A寄存器（如果是A类指令），
 - 或用做整个CPU里不同位置的控制信号（如果是C类指令）
   - 第15位决定指令是A类还是C类；
   - 第12位决定向ALU里输入A还是M；
   - 第6-11位决定ALU进行什么计算；
   - 第3-5位决定ALU结果输出到什么地方；
   - 第0-2位决定是否输出A到PC；
   - 第13-14位没用，C类指令时一般写1。
   
<img alt=“CPU数字逻辑电路图” src=/SVG/CPU.svg>
    
## 芯片做什么事情？
### 只处理二进制数据

   CPU只能接收二进制数据，进行二进制下的数学运算和逻辑运算，输出的也是二进制数据。
   （原因：芯片和数据存储设备的硬件结构限制）

   二进制加减法和逻辑运算是两种毫不相干的运算。
   但是在把逻辑规则中的互相对立结论用0和1来表达时，
   逻辑运算和二进制加减法就有了神奇的重合部分。
   
   比如，1111 1111 1111 1111减去任何一个16位二进制数x[16]，
   得到的结果与对x[16]取非（not x[16]）是一样的。
   由于二进制个位数只有0和1，进位是1。
   所以不论做什么样的运算，每一位上的数无非就是在0和1两者之间变换。
   所以我们是在寻找二进制下的运算结果和逻辑运算结果能重合的规律，
   找到这些规律就能找到实现二进制运算的逻辑门组合。

   所以当我们让CPU帮我们做二进制运算时，CPU实际上只是在做逻辑运算。

### 接收数据输入，一次最多一个
   
   一个16位线宽的CPU，一次最多能从CPU的外部，也就是数据存储设备（比如ROM、RAM）里，获得一个16位的二进制数据，
   经过一个时钟周期的计算后，可以得到一个16位的二进制的计算结果，
   然后在下一个周期，可以把这个结果输入回CPU里进行下一步的运算，或者输出到CPU的外部，写到RAM里。

   虽然运算单元ALU每次都可以接收两个输入，
   但这两个输入里只有一个是接收来自CPU外部的数据，
   另一个则是以前步骤的计算结果暂存到D然后输回给ALU的。

   从CPU外部获取数据有两种来源/方式，
   一是在ROM读出PC指定的地址里的数据，输入A然后再输入ALU；
   另一种是读出RAM里A表示的地址里的数据，然后直接输出给ALU。

### 运算，输出计算结果

   不论是取自程序指令，还是内存，或是前几步的计算结果，一旦把数据给到ALU之后，它就开始运算。
   ALU能做什么样的运算，就意味着CPU能做什么样的运算。

   本课程的ALU有一个16位全加器，它能让x和y进行**加减运算**，
   或者让x、y中任意一个和0、1之间做加减运算；

   另外ALU中的16位与、或、非门，可以支持x和y之间做**与，或，非**的逻辑运算，
   以及x、y之中任意一个和0、1之间做与、或、非的逻辑运算。

 ### 顺序执行程序，或者跳转

   输入什么数据，做什么样的运算，都是由程序指令来控制的。
   程序指令加载在ROM里，CPU会从第一条指令，也就是从ROM[0]的位置开始，一条接一条读取。
   或者说，加载在ROM里的程序会被一条接一条送进CPU里。
   如果没接到跳转指令，那么就会从ROM的第一个寄存器一直读到最后一个寄存器。
   遇到A类指令，就把这条指令本身放到A寄存器里，
   遇到C类指令，这条指令就只会被用做控制信号。
   控制信号会决定让两个输入数据做哪种运算，会控制计算结果输出到什么地方，还会决定下一步读哪条指令。

   读ROM哪个位置，也就是读第几条指令，其实是由PC，指令地址寄存器，控制的，
   我们把PC的硬件设计成启动计算机时PC是0，所以CPU总是会从ROM[0]开始读程序指令。
   然后每读一次（一个时钟周期后）PC自+1，所以一个时钟周期结束，在没有接到特别指令时，下一条就自动被送进CPU。
   如果读到跳转指令：将A写入到了PC里，那么下一个时钟周期，ROM[A]位置的指令会被送入CPU，
   接下来就会从A这个位置往后继续一条一条把指令送入CPU。
   如果reset被按下，会让PC归零，然后又开始从ROM[0]的位置往CPU送指令。
   
## 我们如何指挥“芯片”？
知道了芯片能做的事情，接下来就是如何指挥芯片做我们需要的事，以及我们到底能指挥芯片做什么样的事了。

现如今一个电脑能做的事情非常多，令人惊叹。
显然我们从输入一个二进制数据，然后计算两个二进制数据，得到一个新的二进制数据，
发展出了极其复杂的一套东西让芯片来执行。
能指挥芯片做什么，这个问题已经被人类诠释的丰富的不能再丰富了，
而且似乎延展的可能性仍然是无穷的。

我们是如何指挥芯片完成了如此复杂的工作呢？答案只有两个字：**编程**。

编程语言非常多种多样，我们是这样给他们分类的：
更符合人类语言和思维习惯的一般被称之为（翻译成）高级语言，
芯片直接能认识的叫机器码，接近机器执行逻辑的语言叫低级语言/汇编语言

### 芯片能接受的指令：机器语言/机器码

机器能阅读的程序指令就是一行一行和芯片线宽相同位数的二进制数。这些二进制数可以被分成两大指令类型。
 - A类指令，以0开头（第15位是0）
 
   0vvv vvvv vvvv vvvv。读到这类指令就是告诉芯片，现在向A寄存器里存入刚读到的这个0开头的二进制数字。
   
 - C类指令，以1开头（第15位是1）
 
   111a cccc ccdd djjj。这类指令不会被输入到寄存器或ALU，而是会被加载到整个CPU内部各个地方的控制信号路线上。
   遇到这类指令就是告诉芯片现在按照各个控制信号线路加载的信号去决定运算、输出、和程序跳转。
   - 第6-11位决定ALU进行什么计算；cccccc
   - 第12位决定向ALU里输入A还是M；a
   - 第3-5位决定ALU结果输出到什么地方；ddd
   - 第0-2位决定是否输出A到PC；jjj
   - 第13-14位没用，一般写1。

每种芯片的ALU能进行的运算可以是不一样的。所以每种芯片都有自己对应的机器码和汇编语言。

### 底层语言/低级语言：汇编语言

比0101 1101 0101 0001更适合人阅读的，最接近机器语言的一种编程语言。
用符号来表示不同的机器指令，用这类语言编程与用机器码编程几乎没有区别，相当于是直接指挥芯片。

芯片能做的事情有：
 - 接下来要从外部的什么位置输入一个数据，或不从外部输入数据：

   将ROM里的数输入A：@A <br>
   从RAM[A]取数：M <br>
   就用A里现有的数：A
   
 - 决定ALU做什么样的运算：

   加减法：D+A，M-D，M+1，D-1 <br>
   逻辑运算：D｜M，D&A，！M <br>
   直接输出某个输入数据：D，M，A，0，1，-1
     
 - 把计算结果输出到哪儿：

   哪儿都不输出：null <br>
   一个地方：D=（运算）<br>
   多个地方：AMD=（运算），AD=（运算）
   
 - 接下来是顺序执行下一条程序，还是跳转到某条程序：

   @A<br>
   condition（运算）; jump

   如果condition满足jump条件就跳转（PC=A），不满足就继续执行下一条程序（PC++）。

以上四类符号指令与机器指令是逐一对应的，
借助汇编器就可以把些符号一条对一条地转换成二进制的机器码。

另外借助汇编器还可以比较轻松的实现标签功能。
一类标签是对RAM常用地址进行命名，这样需要取用这些地址的数据，写@A，D=M这类语句的时候，指向更清晰一些。
汇编器翻译时，只需要建立一个常用RAM地址名标签表，把所有@地址命标签的，都替换就可以。
另一类标签是标记程序执行过程中的跳入跳出点，
跳入和跳出都加同样名称的标签，不同的格式。由汇编器在翻译机器码时，
根据标签名称，就可以在跳出指令中写入正确的跳入位置（指令的序号）。

### 中间语言，虚拟机

## 从高级语言到底层语言


## 操作系统、软件和程序语言、编程之间的关系
