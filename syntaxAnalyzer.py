# -*- coding: utf-8 -*-
"""syntaxAnalyzer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CKJRhUn3t16ktW45396bd0GNF6FjnqnV
"""

class JackTokenizer:
  currentToken=''

  #打开输入文件并做好tokenizer的准备
  '''去掉注释和空字符，把输入文件直接整理成一个tokens的集合(tokenList)'''
  def __init__(self,inFile):
    #处理输入文件，去掉注释和空行只留下Jack程序语句
    codes=[]
    symbol=('{','}','(',')','[',']','.',',',';',
      '+','-','*','/','&','|','<','>','=','~')
    self.__symbol=symbol
    with open(inFile,'r') as openFile:
      line=openFile.readline()
      while True:
        cleanLine=line.lstrip().rstrip()
        if not line:
          break
        elif line.isspace() or cleanLine.startswith('//'):
          line=openFile.readline()
        elif cleanLine.startswith('/*') or cleanLine.startswith('/**'):
          while not cleanLine[-2:]=='*/':
            line=openFile.readline()
            cleanLine=line.lstrip().rstrip()
          line=openFile.readline()
        else:
          noComments=cleanLine.rsplit('//',1)
          codes.append(noComments[0])
          line=openFile.readline()
    openFile.close()

    #把程序语句codes进一步拆分成tokenList
    token=''
    tokenList=[]
    for item in codes:
      i=0
      while i<len(item):
        #stringConstant循环
        if item[i]=='"':
          #遇到双引号，直接把下一个双引号之前的字符都取进token里
          token+=item[i]
          i+=1
          while not item[i]=='"':
            token+=item[i]
            i+=1
          #把第二个双引号和token里的字符一起推入tokenList，清空token
          else:
            token+=item[i]
            tokenList.append(token)
            token=''
            i+=1
        #非stringConstant循环
        else:
          #没遇到空格或符号时，把读到的字符顺序取进token里
          if not item[i].isspace():
            if not item[i] in symbol:
              token+=item[i]
            #遇到符号，上一个token结束
            else:
              #把上个token和符号一起推入tokenList，清空token
              if token:
                tokenList.append(token)
                token=''
                tokenList.append(item[i])
              #如果上个字符是空格或符号，此时token里没有内容，直接把符号推入tokenList
              else:
                tokenList.append(item[i])
          #遇到空格，上一个token结束
          else:
            #把上个token推入tokenList，清空token，空格不用推入tokenList
            if token:
              tokenList.append(token)
              token=''
          i+=1
    self.tokenList=tokenList
    return

  #输入文件(tokenList)里还有没有没处理的token？
  '''Return boolean'''
  def hasMoreTokens(self):
    tokenList=self.tokenList
    if len(tokenList)>0:
      boolean=True
    else:
      boolean=False
    return boolean

  #从输入文件(tokenList)里取得下一个token，并且把它作为currentToken
  '''
  这个method应该在hasMoreTokens为真的时候才被调用。
  且一开始的时候currentToken应该是空的。
  '''
  def advance(self):
    tokenList=self.tokenList
    self.currentToken=tokenList.pop(0)
    return

  #确定token的种类，返回token类型
  '''Return a constant'''
  def tokenType(self):
    currentToken=self.currentToken
    keyword=('class','constructor','function','method','field','static',
      'var','int','char','boolean','void','true','false','null','this',
      'let','do','if','else','while','return')
    symbol=self.__symbol
    number=('0','1','2','3','4','5','6','7','8','9')
    if currentToken in keyword:
      tokenType='keyword'
    elif currentToken in symbol:
      tokenType='symbol'
    elif currentToken.startswith('"') and currentToken.endswith('"'):
      tokenType='stringConstant'
    elif currentToken.startswith(number):
      tokenType='integerConstant'
    else:
      tokenType='identifier'
    return tokenType

  #只在tokenType是keyword时才被调用，返回currentToken
  '''Return class,method,function,construciotn,
  int,boolean,char,void,var,static,field,
  let,do,if,else,while,return,true,false,null,this'''
  def keyword(self):
    return self.currentToken

  #只在tokenType是symbol时才被调用，返回currentToken
  '''Return char'''
  def symbol(self):
    return self.currentToken

  #只在tokenType是identifier时才被调用，返回currentToken
  '''Return string'''
  def identifier(self):
    return self.currentToken

  #只在tokenType是integerConstant时才被调用，返回currentToken
  '''Return int'''
  def intVal(self):
    return self.currentToken

  #只在tokenType是stringConstant时才被调用，返回currentToken去掉双引号
  '''Return string'''
  def stringVal(self):
    currentToken=self.currentToken
    stringVal=currentToken.rstrip('"').lstrip('"')
    return stringVal

class CompilationEngine:
  def __init__(self,outFile,tknzr):
    self.__outFile=outFile
    self.__tknzr=tknzr
    return

  def __process(self,str):
    tknzr=self.__tknzr
    tkType=tknzr.tokenType()
    if tkType=='keyword':
      Token=tknzr.keyword()
    elif tkType=='symbol':
      Token=tknzr.symbol()
    elif tkType=='identifier':
      Token=tknzr.identifier()
    elif tkType=='integerConstant':
      Token=tknzr.intVal()
    elif tkType=='stringConstant':
      Token=tknzr.stringVal()
    if Token in str:
      #将Token里的<,>,",&替换成XML可识别的代号
      XMLToken=Token.replace('&','&amp;').replace('<','&lt;'). \
      replace('>','&gt;').replace('"','&quot;')
      XML='<'+tkType+'> '+XMLToken+' </'+tkType+'>'
      file=open(self.__outFile,'a')
      file.writelines(XML+'\n')
      file.close()
    else:
      print(Token+' '+str+' '+'syntax error')
    if tknzr.hasMoreTokens():
      tknzr.advance()
    return

  def __XMLlabel(self,label):
    file=open(self.__outFile,'a')
    file.writelines(label+'\n')
    file.close()
    return

  #class语法：'class' className '{' 'classVarDec* subroutineDec* '}'
  def compileClass(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<class> ')  #开始label
    self.__process(('class'))   #class(keyword)
    className=tknzr.identifier()
    self.__process((className))   #className(identifier)
    self.__process(('{'))   #'{'(symbol)
    #classVarDec*，0或多次，遇到field或static
    while tknzr.keyword() in ('field','static'):
      self.compileClassVarDec()
    #subroutineDec*，0或多词，遇到constructor或function或method
    while tknzr.keyword() in ('constructor','function','method'):
      self.compileSubroutineDec()
    self.__process(('}'))   #'}'(symbol)
    self.__XMLlabel('</class> ')   #结束label
    return

  #classVarDec语法：('static'|'field') type varName (','varName)* ';'
  def compileClassVarDec(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<classVarDec> ')  #开始label
    self.__process(('field','static'))    #static或field(keyword)
    #type，int或char或boolean或className(keyword或identifier)
    if not tknzr.tokenType()=='keyword':
      className=tknzr.identifier()
      self.__process((className))   #className(identifier)
    else:
      str=('int','char','boolean')
      self.__process(str)   #int或char或boolean(keyword)
    varName=tknzr.identifier()
    self.__process((varName))    #varName(identifier)
    #(','varName)*，0或多次，遇到逗号
    while tknzr.symbol()==',':
      self.__process((','))   #','(symbol)
      varName=tknzr.identifier()
      self.__process((varName))   #varName(identifier)
    self.__process((';'))   #';'(symbol)
    self.__XMLlabel('</classVarDec> ')   #结束label
    return

  #subroutineDec语法：('constructor'|'function'|'method') ('void'|type)
  #subroutineName '(' parameterList ')' subroutineBody
  def compileSubroutineDec(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<subroutineDec> ')  #开始label
    #constructor或function或method
    self.__process(('constructor','function','method'))
    #void或type
    if not tknzr.tokenType()=='keyword':
      className=tknzr.identifier()  #className(identifier)
      self.__process((className))
    else:
      str=('void','int','char','boolean')   #void或type(int/char/boolean)
      self.__process(str)
    subroutineName=tknzr.identifier()
    self.__process((subroutineName))    #subroutineName(identifier)
    self.__process(('('))   #'('(symbol)
    #parameterList，(parameter(,p)*)?，取决于'('后面是不是')'
    if not tknzr.symbol()==')':
      self.compileParameterList()
    else:
      self.__XMLlabel('<parameterList>')
      self.__XMLlabel('</parameterList>') #parameterList空Label
    self.__process((')'))   #')'(symbol)
    self.compileSubroutineBody()    #subroutineBody
    self.__XMLlabel('</subroutineDec> ')    #结束label
    return

  #parameterList语法：(type varName) (',' type varName)*
  def compileParameterList(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<parameterList>')  #开始label
    #type varName
    if not tknzr.tokenType()=='keyword':
      className=tknzr.identifier()
      self.__process((className))   #type:className(identifier)
    else:
      str=('int','char','boolean')
      self.__process(str)   #type:int或char或boolean(keyword)
    varName=tknzr.identifier()
    self.__process((varName))   #varName(identifier)
    #(','type varName)*
    while tknzr.symbol()==',':
      self.__process((','))   #','(symbol)
      if not tknzr.tokenType()=='keyword':
        className=tknzr.identifier()
        self.__process((className))   #type:className(identifier)
      else:
        str=('int','char','boolean')
        self.__process(str)   #type:int或char或boolean(keyword)
      varName=tknzr.identifier()
      self.__process((varName))   #varName(identifier)
    self.__XMLlabel(' </parameterList>')    #结束label
    return

  #subroutineBody语法：'{' varDec* statements '}'
  def compileSubroutineBody(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<subroutineBody> ')    #开始label
    self.__process(('{'))   #'{'(symbol)
    #varDec*，0或多个，遇到'var'
    while tknzr.keyword()=='var':
      self.compileVarDec()
    self.compileStatements()    #statements
    self.__process(('}'))   #'}'(symbol)
    self.__XMLlabel(' </subroutineBody>')    #结束label
    return

  #语法：'var' type varName (','varName)* ';'
  def compileVarDec(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<varDec> ')    #开始label
    self.__process(('var'))   #var(keyword)
    #type
    if not tknzr.tokenType()=='keyword':
      className=tknzr.identifier()
      self.__process((className))   #className(identifier)
    else:
      str=('int','char','boolean')
      self.__process(str)   #int或char或boolean(keyword)
    varName=tknzr.identifier()
    self.__process((varName))    #varName(identifier)
    #(','varName)*
    while tknzr.symbol()==',':
      self.__process((','))   #','(symbol)
      varName=tknzr.identifier()
      self.__process((varName))   #varName(identifier)
    self.__process((';'))   #';'(symbol)
    self.__XMLlabel(' </varDec>')    #结束label
    return

  #statements语法：statement*
  def compileStatements(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<statements> ')    #开始label
    while tknzr.keyword() in ('let','if','while','do','return'):
      if tknzr.keyword()=='let':
        self.compileLet()
      elif tknzr.keyword()=='if':
        self.compileIf()
      elif tknzr.keyword()=='while':
        self.compileWhile()
      elif tknzr.keyword()=='do':
        self.compileDo()
      elif tknzr.keyword()=='return':
        self.compileReturn()
    self.__XMLlabel(' </statements>')    #结束label
    return

  #let语法：'let'varName('['expression']')?'='expression';’
  def compileLet(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<letStatement> ')    #开始label
    self.__process(('let'))   #let(keyword)
    varName=tknzr.identifier()
    self.__process((varName))   #varName(identifier)
    #0或1个'['expression']'
    if tknzr.symbol()=='[':
      self.__process(('['))   #'['(symbol)
      self.compileExpression()   #expression
      self.__process((']'))   #']'(symbol)
    self.__process(('='))   #'='(symbol)
    self.compileExpression()   #expression
    self.__process((';'))   #';'(symbol)
    self.__XMLlabel(' </letStatement>')    #结束label
    return

  #if语法：'if''('expression')''{'statements'}'('else''{'statements'}')?
  def compileIf(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<ifStatement> ')    #开始label
    self.__process(('if'))   #if(keyword)
    self.__process(('('))   #'('(symbol)
    self.compileExpression()   #expression
    self.__process((')'))   #')'(symbol)
    self.__process(('{'))   #'{'(symbol)
    self.compileStatements()   #statements
    self.__process(('}'))   #'}'(symbol)
    #0或1个'else''{'statements'}'
    if tknzr.keyword()=='else':
      self.__process(('else'))   #else(keyword)
      self.__process(('{'))   #'{'(symbol)
      self.compileStatements()   #statements
      self.__process(('}'))   #'}'(symbol)
    self.__XMLlabel(' </ifStatement>')    #结束label
    return

  #while语法: 'while' '(' expression ')' '{' statements '}'
  def compileWhile(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<whileStatement> ')    #开始label
    self.__process(('while'))   #while(keyword)
    self.__process(('('))   #'('(symbol)
    self.compileExpression()   #expression
    self.__process((')'))   #')'(symbol)
    self.__process(('{'))   #'{'(symbol)
    self.compileStatements()   #statements
    self.__process(('}'))   #'}'(symbol)
    self.__XMLlabel(' </whileStatement>')    #结束label
    return

  #do语法：'do' subroutineCall ';'
  def compileDo(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<doStatement> ')    #开始label
    self.__process(('do'))   #do(keyword)
    #subroutineCall，
    #subroutineName '(' expressionList ')'|
    #(classnName|varName) '.' subroutineName '(' expressionList ')'
    name=tknzr.identifier()
    self.__process((name))
    if tknzr.symbol()=='.':   #看name后面有没有'.'
      self.__process(('.'))
      subroutineName=tknzr.identifier()
      self.__process((subroutineName))
    self.__process(('('))   #'('(symbol)
    #expressionList，(expression(,e)*)?，取决于'('后面是不是')'
    if not tknzr.symbol()==')':
      self.compileExpressionList()
    else:
      self.__XMLlabel('<expressionList>')
      self.__XMLlabel('</expressionList>') #expressionList空Label
    self.__process((')'))   #')'(symbol)
    #';'(symbol)
    self.__process((';'))
    self.__XMLlabel(' </doStatement>')    #结束label
    return

  #return语法：'return' expression? ';'
  def compileReturn(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<returnStatement> ')    #开始label
    self.__process(('return'))   #return(keyword)
    if not tknzr.symbol()==';':
      self.compileExpression()   #expression
    self.__process((';'))   #';'(symbol)
    self.__XMLlabel(' </returnStatement>')    #结束label
    return

  #expression语法：term (op term)*
  def compileExpression(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<expression> ')    #开始label
    self.compileTerm()  #term
    op=('+','-','*','/','&','|','<','>','=')
    while tknzr.symbol() in op:
      #op
      #待删除self.__XMLlabel('<op> ')    #开始label
      opSymbol=tknzr.symbol()
      self.__process((opSymbol))    #op(symbol)
      #待删除self.__XMLlabel(' </op>')    #结束label
      #term
      self.compileTerm()  #term
    self.__XMLlabel(' </expression>')    #结束label
    return

  #term语法：integerConstant|stringConstant|keywordConstant|varName|
  #varName'['expression']'|subroutineCall|'('expression')'|unaryOp term
  def compileTerm(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<term> ')    #开始label
    #intergerConstant
    if tknzr.tokenType()=='integerConstant':
      num=str(tknzr.intVal())
      self.__process((num))
    #stringConstant
    elif tknzr.tokenType()=='stringConstant':
      string=tknzr.stringVal()
      self.__process((string))
    #keywordConstant(keyword)
    elif tknzr.keyword() in ('true','false','null','this'):
      kw=tknzr.keyword()
      self.__process((kw))
    #'('expression')'
    elif tknzr.symbol()=='(':
      self.__process(('('))   #'('(symbol)
      self.compileExpression()    #expression
      self.__process((')'))   #')'(symbol)
    #unaryOp term
    elif tknzr.symbol() in ('-','~'):
      unarOp=tknzr.symbol()
      self.__process((unarOp))    #unarOp(symbol)
      self.compileTerm()    #term
    #varName|varName'['expression']'|subroutineCall
    elif tknzr.tokenType()=='identifier':
      #如果下一个token什么都不触发，则是varName
      varName=tknzr.identifier()
      self.__process((varName))
      #如果接下来的token是'('，则是subroutineName
      if tknzr.symbol()=='(':
        self.__process(('('))   #'('(symbol)
        #expressionList，(expression(,e)*)?，取决于'('后面是不是')'
        if not tknzr.symbol()==')':
          self.compileExpressionList()
        else:
          self.__XMLlabel('<expressionList>')
          self.__XMLlabel('</expressionList>') #expressionList空Label
        self.__process((')'))   #')'(symbol)
      #如果接下来的token是'.'，则是name.subroutineName
      elif tknzr.symbol()=='.':
        self.__process(('.'))
        subroutineName=tknzr.identifier()
        self.__process((subroutineName))
        self.__process(('('))   #'('(symbol)
        #expressionList，(expression(,e)*)?，取决于'('后面是不是')'
        if not tknzr.symbol()==')':
          self.compileExpressionList()
        else:
          self.__XMLlabel('<expressionList>')
          self.__XMLlabel('</expressionList>') #expressionList空Label
        self.__process((')'))   #')'(symbol)
      #如果接下来的token是'['，则是varName'['expression']'
      elif tknzr.symbol()=='[':
        self.__process(('['))   #'['(symbol)
        self.compileExpression()
        self.__process((']'))   #']'(symbol)
    self.__XMLlabel(' </term>')    #结束label
    return

  #expressionList语法：（expression(',' expression)*)?
  def compileExpressionList(self):
    tknzr=self.__tknzr
    self.__XMLlabel('<expressionList> ')    #开始label
    self.compileExpression()   #expression
    while tknzr.symbol()==',':
      self.__process((','))   #','(symbol)
      self.compileExpression()   #expression
    self.__XMLlabel(' </expressionList>')    #结束label
    return

class JackAnalyzer:
  def __init__(self):
    import os
    #用户输入
    path=input('输入一个jack文件或包含jack文件的文件夹的路径')
    fileType='.jack'

    #判断输入的是文件还是文件夹，如果是文件路径
    if os.path.isfile(path):
      #检查一下文件是不是jack文件
      if path.endswith(fileType):
        self.translation(path)

    #如果输入的是文件夹路径
    elif os.path.isdir(path):
      files=os.listdir(path)
      jackFiles=[]
      #找出文件夹里的vm文件，写成列表
      for f in files:
        if f.endswith(fileType):
          fpath=path+'/'+f
          jackFiles.append(fpath)
      #如果文件夹里有vm文件
      if len(jackFiles)>0:
        for f in jackFiles:
          self.translation(f)

      #如果文件夹里不包含vm文件，返回错误提示
      else:
        print('输入路径下不存在可供转译的.jack文件')
    return

  def translation(self,filePath):
    #新建一个tokenizer
    tknzr=JackTokenizer(filePath)

    #建立一个输出文件filename.xml
    inFile=filePath
    outFile=inFile.split('.')[0]+'.xml'
    creatFile=open(outFile,'w')
    creatFile.write('')
    creatFile.close()

    #新建一个CompliationEngine
    cmplegn=CompilationEngine(outFile,tknzr)

    #调用compileClass公式开始编译
    tknzr.advance()
    cmplegn.compileClass()

    #如果还有没处理的token
    while tknzr.hasMoreTokens():
      tkType=tknzr.tokenType()
      tknzr.advance()
    return

if __name__ == "__main__":
  JackAnalyzer()